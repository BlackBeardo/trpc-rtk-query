import { configureStore } from "@reduxjs/toolkit";
import { type BaseQueryApi, createApi } from "@reduxjs/toolkit/query/react";
import { createTRPCProxyClient } from "@trpc/client";
import { setTimeout } from "node:timers/promises";
import React from "react";
import { Provider } from "react-redux";
import renderer from "react-test-renderer";
import { beforeAll, describe, expect, it, vi } from "vitest";

import { createTRPCApi, injectTRPCEndpointsToApi } from "../src/create-trpc-api";
import {
  type AppRouter,
  startTestServer,
  testClientOptions,
  userFixtures,
} from "./fixtures";

describe("create-trpc-api", () => {
  // Client side options that can be passed in when testing
  const existingApiTestQueryArgument = "giveMeData";
  const existingApiTestQuerySuccessResponse = {
    returning: "data",
  };
  const existingApiTestQueryFailureResponse = {
    error: "bad stuff happened",
  };
  // helper so we can always generate new api instance when needed
  const createApiLazily = () =>
    createApi({
      baseQuery: (baseQueryArguments: { getResponseArgument: string }) => {
        if (baseQueryArguments.getResponseArgument !== existingApiTestQueryArgument) {
          return existingApiTestQueryFailureResponse;
        }
        return {
          data: existingApiTestQuerySuccessResponse,
        };
      },
      endpoints: (builder) => ({
        getResponse: builder.query<string, string>({
          query: (getResponseArgument: string) => ({
            getResponseArgument,
          }),
        }),
      }),
    });

  describe.each([
    {
      testCase: "using api generated by createTRPCApi",
    },
    {
      apiForCreateApiOptions: {
        createApiLazily,
      },
      testCase: "using pre made api",
    },
  ])("when $testCase and ", ({ apiForCreateApiOptions }) => {
    describe.each([
      {
        getApi: () => {
          const base = { clientOptions: testClientOptions };
          if (apiForCreateApiOptions?.createApiLazily) {
            const existingApi = createApiLazily();
            return injectTRPCEndpointsToApi<AppRouter, typeof existingApi>({
              ...base,
              existingApi,
            });
          }
          return createTRPCApi<AppRouter>(base);
        },
        testCase: "creating client from clientOptions",
      },
      {
        getApi: () => {
          const base = {
            client: createTRPCProxyClient<AppRouter>(testClientOptions),
          };
          if (apiForCreateApiOptions?.createApiLazily) {
            const existingApi = createApiLazily();
            return injectTRPCEndpointsToApi<AppRouter, typeof existingApi>({
              ...base,
              existingApi,
            });
          }
          return createTRPCApi(base);
        },
        testCase: "using passed client",
      },
      {
        getApi: () => {
          const base = {
            getClient: async (baseQueryApi: BaseQueryApi) => {
              // Check that correct apiArgs object is passed
              expect(baseQueryApi.type).toBeDefined();
              expect(baseQueryApi.endpoint).toBeDefined();
              // Return proxy client
              return createTRPCProxyClient<AppRouter>(testClientOptions);
            },
          };
          if (apiForCreateApiOptions?.createApiLazily) {
            const existingApi = createApiLazily();
            return injectTRPCEndpointsToApi<AppRouter, typeof existingApi>({
              ...base,
              existingApi,
            });
          }
          return createTRPCApi(base);
        },
        testCase: "using getClient to get the client",
      },
    ])("when $testCase", ({ getApi }) => {
      it("Generates an api instance", () => {
        const api = getApi();
        expect(api).toBeDefined();
      });
      it("Generates queries ", () => {
        const api = getApi();
        const { useGetUserByIdQuery, useListUsersQuery } = api;
        expect(useGetUserByIdQuery).toBeDefined();
        expect(useListUsersQuery).toBeDefined();
      });
      it("Generates mutations with correct typings", () => {
        const api = getApi();
        const { useCreateUserMutation, useUpdateNameMutation } = api;
        expect(useUpdateNameMutation).toBeDefined();
        expect(useCreateUserMutation).toBeDefined();
      });
      it.each([
        "useQuery",
        "useQueryState",
        "useQuerySubscription",
        "useLazyQuery",
        "useLazyQuerySubscription",
      ] as const)(
        "Generates %s hook when accessing hooks through endpoints[endpoint] property",
        (queryName) => {
          const api = getApi();
          const query = api.endpoints.getUserById[queryName];
          expect(query).toBeDefined();
        },
      );
      it("Generates usePrefetch", () => {
        const api = getApi();
        const { usePrefetch } = api;
        expect(usePrefetch).toBeDefined();
      });

      it("Generates hook for deeply nested route", () => {
        const api = getApi();
        const { useNested_Deep_GetVeryNestedMessageQuery } = api;
        expect(useNested_Deep_GetVeryNestedMessageQuery).toBeDefined();
      });

      it("Generates hook for deeply nested routes through endpoints[endpoint]", () => {
        const api = getApi();
        const query =
          api.endpoints.nested_Deep_GetVeryNestedMessage.useQuerySubscription;
        expect(query).toBeDefined();
      });
      describe("and making actual requests with hooks renders correctly", () => {
        // render component to json for snapshots
        // eslint-disable-next-line unicorn/consistent-function-scoping
        const renderedToJSon = (component: renderer.ReactTestRenderer) => {
          const result = component.toJSON();
          expect(result).toBeDefined();
          expect(result).not.toBeInstanceOf(Array);
          return result as renderer.ReactTestRendererJSON;
        };

        // Keep this in scope for easier type deriving
        // eslint-disable-next-line unicorn/consistent-function-scoping
        const createReactTestApp = (getApiForStore: typeof getApi) => {
          const api = getApiForStore();
          const store = configureStore({
            middleware: (getDefaultMiddleware) => [
              ...getDefaultMiddleware(),
              api.middleware,
            ],
            reducer: {
              [api.reducerPath]: api.reducer,
            },
          });

          const createComponentWrapper = (Component: () => React.JSX.Element) =>
            renderer.create(
              <Provider store={store}>
                <Component />
              </Provider>,
            );
          return {
            api,
            createComponentWrapper,
            store,
          };
        };

        // how much to wait for loading state to resolve
        // TODO: fix with using actual rerender with waitFor from testing-library
        const msToWaitBeforeRenderingWithoutLoadingState = 150;
        beforeAll(async () => {
          const { close } = await startTestServer();
          console.log("waiting a bit before running integration tests");
          await setTimeout(250);
          return () => close();
        });
        it("with successful useUserIdQuery", async () => {
          const { api, createComponentWrapper } = createReactTestApp(getApi);
          const Component = () => {
            const { useGetUserByIdQuery } = api;
            const userId = 1;
            const { data, error, isLoading } = useGetUserByIdQuery(userId);
            if (isLoading) {
              return <div>Loading...</div>;
            }
            if (error || !data) {
              return <div>Error</div>;
            }
            expect(data).toEqual(userFixtures[1]);
            return (
              <div>
                <p>Id: {data.id}</p>
                <p>Name: {data.name}</p>
              </div>
            );
          };
          const app = createComponentWrapper(Component);
          // first render
          let result = renderedToJSon(app);
          await setTimeout(msToWaitBeforeRenderingWithoutLoadingState);
          expect(result).toMatchSnapshot();
          // This render needs a bit more time for getClient case, I guess because of
          // forming queryClient takes a bit more time
          // TODO: plz fix with waitFor or something
          // result after data has loaded and component has re-rendered
          result = renderedToJSon(app);
          expect(JSON.stringify(result)).not.toContain("Loading...");
          expect(JSON.stringify(result)).not.toContain("Error");
          expect(result).toMatchSnapshot();
        });
        it("with failing useUserIdQuery", async () => {
          const { api, createComponentWrapper } = createReactTestApp(getApi);
          const Component = () => {
            const { useGetUserByIdQuery } = api;
            const userId = 4;
            // TODO: errors should be properly typed from basequery!
            const { data, error, isLoading } = useGetUserByIdQuery(userId);
            if (isLoading) {
              return <div>Loading...</div>;
            }
            if (error || !data) {
              return <div>Error</div>;
            }
            expect(data).toEqual(userFixtures[1]);
            return (
              <div>
                <p>Id: {data.id}</p>
                <p>Name: {data.name}</p>
              </div>
            );
          };
          const app = createComponentWrapper(Component);
          // first render
          let result = renderedToJSon(app);
          expect(result).toMatchSnapshot();
          await setTimeout(msToWaitBeforeRenderingWithoutLoadingState);
          // result after data has loaded and component has re-rendered
          result = renderedToJSon(app);
          expect(JSON.stringify(result)).not.toContain("Loading...");
          expect(JSON.stringify(result)).toContain("Error");
          expect(result).toMatchSnapshot();
        });
        it("with successful deep nested query", async () => {
          const { api, createComponentWrapper } = createReactTestApp(getApi);
          const Component = () => {
            const { useNested_Deep_GetVeryNestedMessageQuery } = api;
            const myInput = "heyoooo";
            const { data, error, isLoading } = useNested_Deep_GetVeryNestedMessageQuery(
              {
                deepInput: myInput,
              },
            );
            if (isLoading) {
              return <div>Loading...</div>;
            }
            if (error || !data) {
              return <div>Error</div>;
            }
            expect(data.inputBack).toStrictEqual(myInput);
            return (
              <div>
                <p>inputBack: {data.inputBack}</p>
                <p>messageFromDeep: {data.messageFromDeep}</p>
              </div>
            );
          };
          const app = createComponentWrapper(Component);
          // first render
          let result = renderedToJSon(app);
          expect(result).toMatchSnapshot();
          await setTimeout(msToWaitBeforeRenderingWithoutLoadingState);
          // result after data has loaded and component has re-rendered
          result = renderedToJSon(app);
          expect(JSON.stringify(result)).not.toContain("Loading...");
          expect(JSON.stringify(result)).not.toContain("Error");
          expect(result).toMatchSnapshot();
        });
        it("with call to usePrefetch", async () => {
          const { api, createComponentWrapper } = createReactTestApp(getApi);
          const userId = 1;
          const PrefetcherComponent = () => {
            const { usePrefetch } = api;
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore ignore for now, for runtime testing. Fix type later
            const prefetch = usePrefetch("getUserById");
            expect(prefetch).toBeDefined();
            prefetch(userId);
            return <>prefetched</>;
          };
          const QueryComponent = () => {
            const { useQueryState } = api.endpoints.getUserById;
            const { data } = useQueryState(userId);
            expect(data).toEqual(userFixtures[1]);
            return (
              <div>
                <p>Id: {data!.id}</p>
                <p>Name: {data!.name}</p>
              </div>
            );
          };
          const Parent = () => {
            const [showQueryComponent, setShowQueryComponent] = React.useState(false);
            const handleMouseEnter = () => {
              setShowQueryComponent(true);
            };
            return (
              <div onMouseEnter={handleMouseEnter}>
                {showQueryComponent ? <QueryComponent /> : <PrefetcherComponent />}
              </div>
            );
          };
          // render prefetcher component
          const component = createComponentWrapper(Parent);
          let result = renderedToJSon(component);
          expect(JSON.stringify(result)).toContain("prefetched");
          expect(result).toMatchSnapshot();
          // wait for data to load
          await setTimeout(msToWaitBeforeRenderingWithoutLoadingState);
          // manually trigger the callback
          result.props["onMouseEnter"]();
          // render query component and check that prefetch was actually called
          // properly through proxy (e.g. query state should be loaded)
          result = renderedToJSon(component);
          expect(JSON.stringify(result)).not.toContain("Error");
          expect(JSON.stringify(result)).toContain("Id");
          expect(JSON.stringify(result)).toContain("Name");
          expect(result).toMatchSnapshot();
        });
        it("does not inject endpoints again", async () => {
          const { api, createComponentWrapper } = createReactTestApp(getApi);
          // Try to listen error log from rtk
          const consoleErrorMock = vi
            .spyOn(console, "error")
            // eslint-disable-next-line @typescript-eslint/no-empty-function
            .mockImplementation(() => {});
          const FirstComponent = () => {
            const { useListUsersQuery } = api;
            const { data } = useListUsersQuery();
            return <>{JSON.stringify(data)}</>;
          };
          const SecondComponent = () => {
            const { useListUsersQuery } = api;
            const { data } = useListUsersQuery();
            return <>{JSON.stringify(data)}</>;
          };
          const Parent = () => {
            return (
              <>
                <FirstComponent />
                <SecondComponent />
              </>
            );
          };
          const app = createComponentWrapper(Parent);
          // first render
          renderedToJSon(app);
          expect(consoleErrorMock).not.toHaveBeenCalled();
        });
      });
      it("Can be extended with enchangeEndpoints", () => {
        const api = getApi();
        expect(api.enhanceEndpoints).toBeDefined();
        // This is here just to see that it can be executed
        api.enhanceEndpoints({
          addTagTypes: ["User"],
          endpoints: {
            getUserById: {
              // TODO: actually test this works
              // eslint-disable-next-line @typescript-eslint/no-empty-function
              onQueryStarted() {},
              providesTags: ["User"],
            },
            updateName: {
              // TODO: actually test this works
              // eslint-disable-next-line @typescript-eslint/no-empty-function
              onQueryStarted() {},
            },
          },
        });
      });
    });
  });
  it("doesn't replace previous hooks when passing in and existing api", () => {
    const base = { clientOptions: testClientOptions };
    const existingApi = createApiLazily();
    const api = injectTRPCEndpointsToApi<AppRouter, typeof existingApi>({
      ...base,
      existingApi,
    });
    const { useListUsersQuery } = api;
    expect(useListUsersQuery).toBeDefined();
    const { useGetResponseQuery } = api;
    expect(useGetResponseQuery).toBeDefined();
  });
});
