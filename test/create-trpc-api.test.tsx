import { configureStore } from "@reduxjs/toolkit";
import { type BaseQueryApi, createApi } from "@reduxjs/toolkit/query/react";
import { createTRPCProxyClient } from "@trpc/client";
import { AnyRouter } from "@trpc/server";
import { setTimeout } from "node:timers/promises";
import React from "react";
import { Provider } from "react-redux";
import renderer from "react-test-renderer";
import { beforeAll, describe, expect, it, vi } from "vitest";

import {
  type CreateTRPCApiOptions,
  Injectable,
  createTRPCApi,
} from "../src/create-trpc-api";
import {
  type AppRouter,
  startTestServer,
  testClientOptions,
  userFixtures,
} from "./fixtures";

// === Utils ===

// render component to json for snapshots
export const renderedToJSon = (component: renderer.ReactTestRenderer) => {
  const result = component.toJSON();
  expect(result).toBeDefined();
  expect(result).not.toBeInstanceOf(Array);
  return result as renderer.ReactTestRendererJSON;
};

// generate api store and app creator for testing hooks
// TODO: flow Router through
export const createReactTestApp = <
  TRouter extends AnyRouter,
  ExistingApi extends Injectable = never,
>(
  createApiOptions: CreateTRPCApiOptions<TRouter, ExistingApi>,
) => {
  const api = createTRPCApi<TRouter, ExistingApi>(createApiOptions);
  const store = configureStore({
    middleware: (getDefaultMiddleware) => [...getDefaultMiddleware(), api.middleware],
    reducer: {
      [api.reducerPath]: api.reducer,
    },
  });

  const createComponentWrapper = (Component: () => React.JSX.Element) =>
    renderer.create(
      <Provider store={store}>
        <Component />
      </Provider>,
    );
  return {
    api,
    createComponentWrapper,
    store,
  };
};

// === Tests ===

describe("create-trpc-api", () => {
  // Client side options that can be passed in when testing
  const existingApiTestQueryArgument = "giveMeData";
  const existingApiTestQuerySuccessResponse = {
    returning: "data",
  };
  const existingApiTestQueryFailureResponse = {
    error: "bad stuff happened",
  };
  // helper so we can always generate new api instance when needed
  const createApiLazily = () =>
    createApi({
      baseQuery: (baseQueryArguments: { getResponseArgument: string }) => {
        if (baseQueryArguments.getResponseArgument !== existingApiTestQueryArgument) {
          return existingApiTestQueryFailureResponse;
        }
        return {
          data: existingApiTestQuerySuccessResponse,
        };
      },
      endpoints: (builder) => ({
        getResponse: builder.query<string, string>({
          query: (getResponseArgument: string) => ({
            getResponseArgument,
          }),
        }),
      }),
    });

  describe.each([
    {
      testCase: "using api generated by createTRPCApi",
    },
    {
      apiForCreateApiOptions: {
        createApiLazily,
      },
      testCase: "using pre made api",
    },
  ])("when $testCase and ", ({ apiForCreateApiOptions }) => {
    describe.each([
      {
        createApiOptions: {
          api: apiForCreateApiOptions?.createApiLazily?.(),
          clientOptions: testClientOptions,
        },
        testCase: "creating client from clientOptions",
      },
      {
        createApiOptions: {
          api: apiForCreateApiOptions?.createApiLazily?.(),
          client: createTRPCProxyClient<AppRouter>(testClientOptions),
        },
        testCase: "using passed client",
      },
      {
        createApiOptions: {
          api: apiForCreateApiOptions?.createApiLazily?.(),
          getClient: async (baseQueryApi: BaseQueryApi) => {
            // Check that correct apiArgs object is passed
            expect(baseQueryApi.type).toBeDefined();
            expect(baseQueryApi.endpoint).toBeDefined();
            // Return proxy client
            return createTRPCProxyClient<AppRouter>(testClientOptions);
          },
        },
        testCase: "using getClient to get the client",
      },
    ])("when $testCase", ({ createApiOptions }) => {
      it("Generates an api instance", () => {
        const api = createTRPCApi<AppRouter>(createApiOptions);
        expect(api).toBeDefined();
      });
      it("Generates queries ", () => {
        const api = createTRPCApi<AppRouter>(createApiOptions);
        const { useGetUserByIdQuery, useListUsersQuery } = api;
        expect(useGetUserByIdQuery).toBeDefined();
        expect(useListUsersQuery).toBeDefined();
      });
      it("Generates mutations with correct typings", () => {
        const api = createTRPCApi<AppRouter>(createApiOptions);
        const { useCreateUserMutation, useUpdateNameMutation } = api;
        expect(useUpdateNameMutation).toBeDefined();
        expect(useCreateUserMutation).toBeDefined();
      });
      it.each([
        "useQuery",
        "useQueryState",
        "useQuerySubscription",
        "useLazyQuery",
        "useLazyQuerySubscription",
      ] as const)(
        "Generates %s hook when accessing hooks through endpoints[endpoint] property",
        (queryName) => {
          const api = createTRPCApi<AppRouter>(createApiOptions);
          const query = api.endpoints.getUserById[queryName];
          expect(query).toBeDefined();
        },
      );
      it("Generates usePrefetch", () => {
        const api = createTRPCApi<AppRouter>(createApiOptions);
        const { usePrefetch } = api;
        expect(usePrefetch).toBeDefined();
      });

      it("Generates hook for deeply nested route", () => {
        const api = createTRPCApi<
          AppRouter,
          NonNullable<(typeof createApiOptions)["api"]>
        >(createApiOptions);
        const { useNested_Deep_GetVeryNestedMessageQuery } = api;
        expect(useNested_Deep_GetVeryNestedMessageQuery).toBeDefined();
      });
      it("Generates hook for deeply nested routes through endpoints[endpoint]", () => {
        const api = createTRPCApi<
          AppRouter,
          NonNullable<(typeof createApiOptions)["api"]>
        >(createApiOptions);
        // TODO: fix this type
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const query = (api.endpoints.nested_Deep_GetVeryNestedMessage as any)
          .useQuerySubscription;
        expect(query).toBeDefined();
      });
      describe("and making actual requests with hooks renders correctly", () => {
        // how much to wait for loading state to resolve
        // TODO: fix with using actual rerender with waitFor from testing-library
        const msToWaitBeforeRenderingWithoutLoadingState = 150;
        beforeAll(async () => {
          const { close } = await startTestServer();
          return async () => await close();
        });
        it("with successful useUserIdQuery", async () => {
          const { api, createComponentWrapper } = createReactTestApp(createApiOptions);
          const Component = () => {
            const { useGetUserByIdQuery } = api;
            const userId = 1;
            const { data, error, isLoading } = useGetUserByIdQuery(userId);
            if (isLoading) {
              return <div>Loading...</div>;
            }
            if (error || !data) {
              return <div>Error</div>;
            }
            expect(data).toEqual(userFixtures[1]);
            return (
              <div>
                <p>Id: {data.id}</p>
                <p>Name: {data.name}</p>
              </div>
            );
          };
          const app = createComponentWrapper(Component);
          // first render
          let result = renderedToJSon(app);
          await setTimeout(msToWaitBeforeRenderingWithoutLoadingState);
          expect(result).toMatchSnapshot();
          // This render needs a bit more time for getClient case, I guess because of
          // forming queryClient takes a bit more time
          // TODO: plz fix with waitFor or something
          // result after data has loaded and component has re-rendered
          result = renderedToJSon(app);
          expect(JSON.stringify(result)).not.toContain("Loading...");
          expect(JSON.stringify(result)).not.toContain("Error");
          expect(result).toMatchSnapshot();
        });
        it("with failing useUserIdQuery", async () => {
          const { api, createComponentWrapper } = createReactTestApp(createApiOptions);
          const Component = () => {
            const { useGetUserByIdQuery } = api;
            const userId = 4;
            // TODO: errors should be properly typed from basequery!
            const { data, error, isLoading } = useGetUserByIdQuery(userId);
            if (isLoading) {
              return <div>Loading...</div>;
            }
            if (error || !data) {
              return <div>Error</div>;
            }
            expect(data).toEqual(userFixtures[1]);
            return (
              <div>
                <p>Id: {data.id}</p>
                <p>Name: {data.name}</p>
              </div>
            );
          };
          const app = createComponentWrapper(Component);
          // first render
          let result = renderedToJSon(app);
          expect(result).toMatchSnapshot();
          await setTimeout(msToWaitBeforeRenderingWithoutLoadingState);
          // result after data has loaded and component has re-rendered
          result = renderedToJSon(app);
          expect(JSON.stringify(result)).not.toContain("Loading...");
          expect(JSON.stringify(result)).toContain("Error");
          expect(result).toMatchSnapshot();
        });
        it("with successful deep nested query", async () => {
          const { api, createComponentWrapper } = createReactTestApp(createApiOptions);
          const Component = () => {
            const { useNested_Deep_GetVeryNestedMessageQuery } = api;
            const myInput = "heyoooo";
            const { data, error, isLoading } = useNested_Deep_GetVeryNestedMessageQuery(
              {
                deepInput: myInput,
              },
            );
            if (isLoading) {
              return <div>Loading...</div>;
            }
            if (error || !data) {
              return <div>Error</div>;
            }
            expect(data.inputBack).toStrictEqual(myInput);
            return (
              <div>
                <p>inputBack: {data.inputBack}</p>
                <p>messageFromDeep: {data.messageFromDeep}</p>
              </div>
            );
          };
          const app = createComponentWrapper(Component);
          // first render
          let result = renderedToJSon(app);
          expect(result).toMatchSnapshot();
          await setTimeout(msToWaitBeforeRenderingWithoutLoadingState);
          // result after data has loaded and component has re-rendered
          result = renderedToJSon(app);
          expect(JSON.stringify(result)).not.toContain("Loading...");
          expect(JSON.stringify(result)).not.toContain("Error");
          expect(result).toMatchSnapshot();
        });
        it("with call to usePrefetch", async () => {
          const { api, createComponentWrapper } = createReactTestApp(createApiOptions);
          const userId = 1;
          const PrefetcherComponent = () => {
            const { usePrefetch } = api;
            const prefetch = usePrefetch("getUserById");
            expect(prefetch).toBeDefined();
            prefetch(userId);
            return <>prefetched</>;
          };
          const QueryComponent = () => {
            const { useQueryState } = api.endpoints.getUserById;
            const { data } = useQueryState(userId);
            expect(data).toEqual(userFixtures[1]);
            return (
              <div>
                <p>Id: {data!.id}</p>
                <p>Name: {data!.name}</p>
              </div>
            );
          };
          const Parent = () => {
            const [showQueryComponent, setShowQueryComponent] = React.useState(false);
            const handleMouseEnter = () => {
              setShowQueryComponent(true);
            };
            return (
              <div onMouseEnter={handleMouseEnter}>
                {showQueryComponent ? <QueryComponent /> : <PrefetcherComponent />}
              </div>
            );
          };
          // render prefetcher component
          const component = createComponentWrapper(Parent);
          let result = renderedToJSon(component);
          expect(JSON.stringify(result)).toContain("prefetched");
          expect(result).toMatchSnapshot();
          // wait for data to load
          await setTimeout(msToWaitBeforeRenderingWithoutLoadingState);
          // manually trigger the callback
          result.props["onMouseEnter"]();
          // render query component and check that prefetch was actually called
          // properly through proxy (e.g. query state should be loaded)
          result = renderedToJSon(component);
          expect(JSON.stringify(result)).not.toContain("Error");
          expect(JSON.stringify(result)).toContain("Id");
          expect(JSON.stringify(result)).toContain("Name");
          expect(result).toMatchSnapshot();
        });
        it("does not inject endpoints again", async () => {
          const { api, createComponentWrapper } = createReactTestApp(createApiOptions);
          // Try to listen error log from rtk
          const consoleErrorMock = vi
            .spyOn(console, "error")
            // eslint-disable-next-line @typescript-eslint/no-empty-function
            .mockImplementation(() => {});
          const FirstComponent = () => {
            const { useListUsersQuery } = api;
            const { data } = useListUsersQuery();
            return <>{JSON.stringify(data)}</>;
          };
          const SecondComponent = () => {
            const { useListUsersQuery } = api;
            const { data } = useListUsersQuery();
            return <>{JSON.stringify(data)}</>;
          };
          const Parent = () => {
            return (
              <>
                <FirstComponent />
                <SecondComponent />
              </>
            );
          };
          const app = createComponentWrapper(Parent);
          // first render
          renderedToJSon(app);
          expect(consoleErrorMock).not.toHaveBeenCalled();
        });
      });
      it("Can be extended with enchangeEndpoints", () => {
        const api = createTRPCApi<AppRouter>(createApiOptions);
        expect(api.enhanceEndpoints).toBeDefined();
        // This is here just to see that it can be executed
        api.enhanceEndpoints({
          addTagTypes: ["User"],
          endpoints: {
            getUserById: {
              // TODO: actually test this works
              // eslint-disable-next-line @typescript-eslint/no-empty-function
              onQueryStarted() {},
              providesTags: ["User"],
            },
            updateName: {
              // TODO: actually test this works
              // eslint-disable-next-line @typescript-eslint/no-empty-function
              onQueryStarted() {},
            },
          },
        });
      });
    });
  });
  it("doesn't replace previous hooks when passing in and existing api", () => {
    const existingApi = createApiLazily();
    const api = createTRPCApi<AppRouter, typeof existingApi>({
      api: existingApi,
      clientOptions: testClientOptions,
    });
    const { useListUsersQuery } = api;
    expect(useListUsersQuery).toBeDefined();
    const { useGetResponseQuery } = api;
    expect(useGetResponseQuery).toBeDefined();
  });
});
